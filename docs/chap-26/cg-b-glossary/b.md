---
title: B
sidebar_position: 98
---

**B** 



**backquote** *n.* the *standard character* that is variously called “grave accent” or 



“backquote” (‘). See Figure 2–5. 



**backslash** *n.* the *standard character* that is variously called “reverse solidus” or “backslash” (\). See Figure 2–5. 



**base character** *n.* a <ClLinks styled={true} term={"character"}><i>character</i></ClLinks> of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"base-char"}><b>base-char</b></ClLinks>. 



**base string** *n.* a <ClLinks styled={true} term={"string"}><i>string</i></ClLinks> of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"base-string"}><b>base-string</b></ClLinks>. 



**before method** *n.* a <ClLinks styled={true} term={"method"}><i>method</i></ClLinks> having the <ClLinks styled={true} term={"qualifier"}><i>qualifier</i></ClLinks> :before. 



**bidirectional** *adj.* (of a <ClLinks styled={true} term={"stream"}><i>stream</i></ClLinks>) being both an *input stream* and an *output stream*. 



**binary** *adj.* 1. (of a <ClLinks styled={true} term={"stream"}><i>stream</i></ClLinks>) being a <ClLinks styled={true} term={"stream"}><i>stream</i></ClLinks> that has an *element type* that is a 



<ClLinks styled={true} term={"subtype"}><i>subtype</i></ClLinks> of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"integer"}><b>integer</b></ClLinks>. The most fundamental operation on a *binary input stream* is <ClLinks styled={true} term={"read-byte"}><b>read-byte</b></ClLinks> and on a *binary output stream* is <ClLinks styled={true} term={"write-byte"}><b>write-byte</b></ClLinks>. See <ClLinks styled={true} term={"character"}><i>character</i></ClLinks> . 2. (of a <ClLinks styled={true} term={"file"}><i>file</i></ClLinks>) having been created by opening a *binary stream*. (It is <ClLinks styled={true} term={"implementation-dependent"}><i>implementation-dependent</i></ClLinks> whether this is an detectable aspect of the <ClLinks styled={true} term={"file"}><i>file</i></ClLinks>, or whether any given *character file* can be treated as a *binary file*.) 



**bind** *v.t.* (a <ClLinks styled={true} term={"variable"}><i>variable</i></ClLinks>) to establish a <ClLinks styled={true} term={"binding"}><i>binding</i></ClLinks> for the <ClLinks styled={true} term={"variable"}><i>variable</i></ClLinks>. 



**binding** *n.* an association between a <ClLinks styled={true} term={"name"}><i>name</i></ClLinks> and that which the <ClLinks styled={true} term={"name"}><i>name</i></ClLinks> denotes. “A lexical binding is a lexical association between a name and its value.” When the term <ClLinks styled={true} term={"binding"}><i>binding</i></ClLinks> is qualified by the name of a <ClLinks styled={true} term={"namespace"}><i>namespace</i></ClLinks>, such as “variable” or “function,” it restricts the binding to the indicated namespace, as in: “<ClLinks styled={true} term={"let"}><b>let</b></ClLinks> establishes variable bindings.” or “<ClLinks styled={true} term={"let"}><b>let</b></ClLinks> establishes bindings of variables.” 



<ClLinks styled={true} term={"bit"}><b>bit</b></ClLinks> *n.* an <ClLinks styled={true} term={"object"}><i>object</i></ClLinks> of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"bit"}><b>bit</b></ClLinks>; that is, the *integer* 0 or the *integer* 1. 



**bit array** *n.* a specialized <ClLinks styled={true} term={"array"}><i>array</i></ClLinks> that is of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> (array bit), and whose elements are of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"bit"}><b>bit</b></ClLinks>. 



**bit vector** *n.* a specialized <ClLinks styled={true} term={"vector"}><i>vector</i></ClLinks> that is of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"bit-vector"}><b>bit-vector</b></ClLinks>, and whose elements are of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"bit"}><b>bit</b></ClLinks>. 



**bit-wise logical operation specifier** *n.* an <ClLinks styled={true} term={"object"}><i>object</i></ClLinks> which names one of the sixteen possible bit-wise logical operations that can be performed by the <ClLinks styled={true} term={"boole"}><b>boole</b></ClLinks> function, and which is the <ClLinks styled={true} term={"value"}><i>value</i></ClLinks> of exactly one of the *constant variables* <ClLinks styled={true} term={"boole-clr"}><b>boole-clr</b></ClLinks>, <ClLinks styled={true} term={"boole-set"}><b>boole-set</b></ClLinks>, <ClLinks styled={true} term={"boole-1"}><b>boole-1</b></ClLinks>, <ClLinks styled={true} term={"boole-2"}><b>boole-2</b></ClLinks>, <ClLinks styled={true} term={"boole-c1"}><b>boole-c1</b></ClLinks>, <ClLinks styled={true} term={"boole-c2"}><b>boole-c2</b></ClLinks>, <ClLinks styled={true} term={"boole-and"}><b>boole-and</b></ClLinks>, <ClLinks styled={true} term={"boole-ior"}><b>boole-ior</b></ClLinks>, <ClLinks styled={true} term={"boole-xor"}><b>boole-xor</b></ClLinks>, <ClLinks styled={true} term={"boole-eqv"}><b>boole-eqv</b></ClLinks>, <ClLinks styled={true} term={"boole-nand"}><b>boole-nand</b></ClLinks>, <ClLinks styled={true} term={"boole-nor"}><b>boole-nor</b></ClLinks>, <ClLinks styled={true} term={"boole-andc1"}><b>boole-andc1</b></ClLinks>, <ClLinks styled={true} term={"boole-andc2"}><b>boole-andc2</b></ClLinks>, <ClLinks styled={true} term={"boole-orc1"}><b>boole-orc1</b></ClLinks>, or <ClLinks styled={true} term={"boole-orc2"}><b>boole-orc2</b></ClLinks>. 







 



 



<ClLinks styled={true} term={"block"}><b>block</b></ClLinks> *n.* a named lexical *exit point<ClLinks styled={true} term={"t"}><i>, </i></ClLinks>established* explicitly by <ClLinks styled={true} term={"block"}><b>block</b></ClLinks> or implicitly by <ClLinks styled={true} term={"operator"}><i>operators</i></ClLinks> such as <ClLinks styled={true} term={"loop"}><b>loop</b></ClLinks>, <ClLinks styled={true} term={"do"}><b>do</b></ClLinks> and **prog**, to which control and values may be transfered by using a <ClLinks styled={true} term={"return-from"}><b>return-from</b></ClLinks> <ClLinks styled={true} term={"form"}><i>form</i></ClLinks> with the name of the <ClLinks styled={true} term={"block"}><i>block</i></ClLinks>. 



**block tag** *n.* the <ClLinks styled={true} term={"symbol"}><i>symbol</i></ClLinks> that, within the *lexical scope* of a <ClLinks styled={true} term={"block"}><b>block</b></ClLinks> <ClLinks styled={true} term={"form"}><i>form</i></ClLinks>, names the *block established* by that <ClLinks styled={true} term={"block"}><b>block</b></ClLinks> <ClLinks styled={true} term={"form"}><i>form</i></ClLinks>. See <ClLinks styled={true} term={"return"}><b>return</b></ClLinks> or <ClLinks styled={true} term={"return-from"}><b>return-from</b></ClLinks>. 



**boa lambda list** *n.* a *lambda list* that is syntactically like an *ordinary lambda list*, but that is processed in “**b**y **o**rder of **a**rgument” style. See Section 3.4.6 (Boa Lambda Lists). 



**body parameter** *n.* a <ClLinks styled={true} term={"parameter"}><i>parameter</i></ClLinks> available in certain *lambda lists* which from the point of view of *conforming programs* is like a *rest parameter* in every way except that it is introduced by **&amp;body** instead of **&amp;rest**. (<ClLinks styled={true} term={"implementation"}><i>Implementations</i></ClLinks> are permitted to provide extensions which distinguish *body parameters* and *rest parameters*—*e.g.*, the <ClLinks styled={true} term={"form"}><i>forms</i></ClLinks> for <ClLinks styled={true} term={"operator"}><i>operators</i></ClLinks> which were defined using a *body parameter* might be pretty printed slightly differently than <ClLinks styled={true} term={"form"}><i>forms</i></ClLinks> for <ClLinks styled={true} term={"operator"}><i>operators</i></ClLinks> which were defined using *rest parameters*.) 



<ClLinks styled={true} term={"boolean"}><b>boolean</b></ClLinks> *n.* an <ClLinks styled={true} term={"object"}><i>object</i></ClLinks> of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"boolean"}><b>boolean</b></ClLinks>; that is, one of the following <ClLinks styled={true} term={"object"}><i>objects</i></ClLinks>: the 



symbol <ClLinks styled={true} term={"t"}><b>t</b></ClLinks> (representing <ClLinks styled={true} term={"true"}><i>true</i></ClLinks>), or the symbol <ClLinks styled={true} term={"nil"}><b>nil</b></ClLinks> (representing <ClLinks styled={true} term={"false"}><i>false</i></ClLinks>). See *generalized boolean*. 



**boolean equivalent** *n.* (of an *object O*<sub>1</sub>) any *object O*<sub>2</sub> that has the same truth value as *O*<sub>1</sub> when both *O*<sub>1</sub> and *O*<sub>2</sub> are viewed as *generalized booleans*. 



**bound** *adj.*, *v.t.* 1. *adj.* having an associated denotation in a <ClLinks styled={true} term={"binding"}><i>binding</i></ClLinks>. “The variables named by a <ClLinks styled={true} term={"let"}><b>let</b></ClLinks> are bound within its body.” See <ClLinks styled={true} term={"unbound"}><i>unbound</i></ClLinks>. 2. *adj.* having a local <ClLinks styled={true} term={"binding"}><i>binding</i></ClLinks> which <ClLinks styled={true} term={"shadow"}><i>shadows</i></ClLinks><sub>2</sub> another. “The variable <ClLinks styled={true} term={"print-escape"}><b>\*print-escape\*</b></ClLinks> is bound while in the <ClLinks styled={true} term={"princ"}><b>princ</b></ClLinks> function.” 3. *v.t.* the past tense of <ClLinks styled={true} term={"bind"}><i>bind</i></ClLinks>. 



**bound declaration** *n.* a <ClLinks styled={true} term={"declaration"}><i>declaration</i></ClLinks> that refers to or is associated with a <ClLinks styled={true} term={"variable"}><i>variable</i></ClLinks> or <ClLinks styled={true} term={"function"}><i>function</i></ClLinks> and that appears within the *special form* that *establishes* the <ClLinks styled={true} term={"variable"}><i>variable</i></ClLinks> or <ClLinks styled={true} term={"function"}><i>function</i></ClLinks>, but before the body of that *special form* (specifically, at the head of that <ClLinks styled={true} term={"form"}><i>form</i></ClLinks>’s body). (If a *bound declaration* refers to a *function binding* or a *lexical variable binding*, the <ClLinks styled={true} term={"scope"}><i>scope</i></ClLinks> of the <ClLinks styled={true} term={"declaration"}><i>declaration</i></ClLinks> is exactly the <ClLinks styled={true} term={"scope"}><i>scope</i></ClLinks> of that <ClLinks styled={true} term={"binding"}><i>binding</i></ClLinks>. If the 



<ClLinks styled={true} term={"declaration"}><i>declaration</i></ClLinks> refers to a *dynamic variable binding*, the <ClLinks styled={true} term={"scope"}><i>scope</i></ClLinks> of the <ClLinks styled={true} term={"declaration"}><i>declaration</i></ClLinks> is what the <ClLinks styled={true} term={"scope"}><i>scope</i></ClLinks> of the <ClLinks styled={true} term={"binding"}><i>binding</i></ClLinks> would have been if it were lexical rather than dynamic.) 



<b>bounded</b> <i>adj.</i> (of a <i>sequence S</i>, by an ordered pair of <i>bounding indices i<sub>start</sub></i> and <i>i<sub>end</sub></i>) restricted to a subrange of the <i>elements</i> of <i>S</i> that includes each <i>element</i> beginning with (and including) the one indexed by <i>i<sub>start</sub></i> and continuing up to (but not including) the one indexed by <i>i<sub>end</sub></i>. 



<b>bounding index</b> <i>n.</i> (of a <i>sequence</i> with <i>length n</i>) either of a conceptual pair of <i>integers</i>, <i>i<sub>start</sub></i> and <i>i<sub>end</sub></i>, respectively called the “lower bounding index” and “upper 







 



 



bounding index”, such that 0 <i>≤ i<sub>start</sub> ≤ i<sub>end</sub> ≤ n</i>, and which therefore delimit a subrange of the <i>sequence bounded</i> by <i>i<sub>start</sub></i> and <i>i<sub>end</sub></i>. 



**bounding index designator** (for a *sequence*) one of two <ClLinks styled={true} term={"object"}><i>objects</i></ClLinks> that, taken together as an ordered pair, behave as a <ClLinks styled={true} term={"designator"}><i>designator</i></ClLinks> for *bounding indices* of the *sequence*; that is, they denote *bounding indices* of the *sequence*, and are either: an *integer* (denoting 



itself) and <ClLinks styled={true} term={"nil"}><b>nil</b></ClLinks> (denoting the <ClLinks styled={true} term={"length"}><i>length</i></ClLinks> of the *sequence*), or two *integers* (each denoting themselves). 



**break loop** *n.* A variant of the normal *Lisp read-eval-print loop* that is recursively entered, usually because the ongoing <ClLinks styled={true} term={"evaluation"}><i>evaluation</i></ClLinks> of some other <ClLinks styled={true} term={"form"}><i>form</i></ClLinks> has been suspended for the purpose of debugging. Often, a *break loop* provides the ability to exit in such a way as to continue the suspended computation. See the <ClLinks styled={true} term={"function"}><i>function</i></ClLinks> <ClLinks styled={true} term={"break"}><b>break</b></ClLinks>. 



**broadcast stream** *n.* an *output stream* of <ClLinks styled={true} term={"type"}><i>type</i></ClLinks> <ClLinks styled={true} term={"broadcast-stream"}><b>broadcast-stream</b></ClLinks>. 



**built-in class** *n.* a <ClLinks styled={true} term={"class"}><i>class</i></ClLinks> that is a *generalized instance* of <ClLinks styled={true} term={"class"}><i>class</i></ClLinks> <ClLinks styled={true} term={"built-in-class"}><b>built-in-class</b></ClLinks>. 



**built-in type** *n.* one of the <ClLinks styled={true} term={"type"}><i>types</i></ClLinks> in Figure 4–2. 



<ClLinks styled={true} term={"byte"}><b>byte</b></ClLinks> *n.* 1. adjacent bits within an *integer* . (The specific number of bits can vary from point to point in the program; see the <ClLinks styled={true} term={"function"}><i>function</i></ClLinks> <ClLinks styled={true} term={"byte"}><b>byte</b></ClLinks>.) 2. an integer in a specified range. (The specific range can vary from point to point in the program; see the <ClLinks styled={true} term={"function"}><i>functions</i></ClLinks> <ClLinks styled={true} term={"open"}><b>open</b></ClLinks> and <ClLinks styled={true} term={"write-byte"}><b>write-byte</b></ClLinks>.) 



**byte specifier** *n.* An <ClLinks styled={true} term={"object"}><i>object</i></ClLinks> of <ClLinks styled={true} term={"implementation-dependent"}><i>implementation-dependent</i></ClLinks> nature that is returned by the <ClLinks styled={true} term={"function"}><i>function</i></ClLinks> <ClLinks styled={true} term={"byte"}><b>byte</b></ClLinks> and that specifies the range of bits in an *integer* to be used as a <ClLinks styled={true} term={"byte"}><i>byte</i></ClLinks> by <ClLinks styled={true} term={"function"}><i>functions</i></ClLinks> such as <ClLinks styled={true} term={"ldb"}><b>ldb</b></ClLinks>. 



