The defmethod macro
===================

### The `defmethod` macro

The evaluation or execution of a `defmethod` form requires first that the body of the method be converted to a method function. This process is described in the next section. The result of this process is a method function and a set of additional initialization arguments to be used when creating the new method. Given these two values, the evaluation or execution of a `defmethod` form proceeds in three steps. The first step ensures the existence of a generic function with the specified name. This is done by calling the function [ensure-generic-function](ensure-generic-function.md). The first argument in this call is the generic function name specified in the `defmethod` form. The second step is the creation of the new method metaobject by calling [make-instance](make-instance.md). The class of the new method metaobject is determined by calling [generic-function-method-class](generic-function-method-class.md) on the result of the call to [ensure-generic-function](ensure-generic-function.md) from the first step. The initialization arguments received by the call to [make-instance](make-instance.md) are as follows:

-   The value of the `qualifiers` initialization argument is a list of the qualifiers which appeared in the `defmethod` form. No special processing is done on these values. The order of the elements of this list is the same as in the `defmethod` form.
-   The value of the `lambda-list` initialization argument is the unspecialized lambda list from the `defmethod` form.
-   The value of the `specializers` initialization argument is a list of the specializers for the method. For specializers which are classes, the specializer is the class metaobject itself. In the case of `eql` specializers, it will be an [eql-specializer](class-eql-specializer.md) metaobject obtained by calling [intern-eql-specializer](intern-eql-specializer.md) on the result of evaluating the `eql` specializer form in the lexical environment of the `defmethod` form.
-   The value of the `function` initialization argument is the method function.
-   The value of the `declarations` initialization argument is a list of the declarations from the `defmethod` form. If there are no declarations in the macro form, this initialization argument either doesn't appear, or appears with a value of the empty list.
-   The value of the `documentation` initialization argument is the documentation string from the `defmethod` form. If there is no documentation string in the macro form this initialization argument either doesn't appear, or appears with a value of false.
-   Any other initialization argument produced in conjunction with the method function are also included.
-   The implementation is free to include additional initialization arguments provided these are not symbols accessible in the `common-lisp-user` package, or exported by any package defined in the ANSI Common Lisp standard.

In the third step, [add-method](add-method.md) is called to add the newly created method to the set of methods associated with the generic function metaobject. The result of the call to [add-method](add-method.md) is returned as the result of evaluating or executing the `defmethod` form. An example showing a typical `defmethod` form and a sample expansion is shown in [this figure](fig-defmethod-1.md). The processing of the method body for this method is shown in [this figure](fig-defmethod-2.md).
