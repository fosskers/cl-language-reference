 



If <ClLinks styled={true} term={"print-array"}><b>\*print-array\*</b></ClLinks> is <ClLinks styled={true} term={"true"}><i>true</i></ClLinks> and <ClLinks styled={true} term={"print-readably"}><b>\*print-readably\*</b></ClLinks> is <ClLinks styled={true} term={"false"}><i>false</i></ClLinks>, any <ClLinks styled={true} term={"array"}><i>array</i></ClLinks> other than a <ClLinks styled={true} term={"vector"}><i>vector</i></ClLinks> is printed using #nA format. Let n be the <ClLinks styled={true} term={"rank"}><i>rank</i></ClLinks> of the <ClLinks styled={true} term={"array"}><i>array</i></ClLinks>. Then # is printed, then n as a decimal integer, then A, then n open parentheses. Next the <ClLinks styled={true} term={"element"}><i>elements</i></ClLinks> are scanned in row-major order, using <ClLinks styled={true} term={"write"}><b>write</b></ClLinks> on each <ClLinks styled={true} term={"element"}><i>element</i></ClLinks>, and separating <ClLinks styled={true} term={"element"}><i>elements</i></ClLinks> from each other with <ClLinks styled={true} term={"whitespace"}><i>whitespace</i></ClLinks><sub>1</sub>. The array’s dimensions are numbered 0 to n-1 from left to right, and are enumerated with the rightmost index changing fastest. Every time the index for dimension j is incremented, the following actions are taken: 



*•* If j &lt; n-1, then a close parenthesis is printed. 



*•* If incrementing the index for dimension j caused it to equal dimension j, that index is reset to zero and the index for dimension j-1 is incremented (thereby performing these three steps recursively), unless j=0, in which case the entire algorithm is terminated. If incrementing the index for dimension j did not cause it to equal dimension j, then a space is printed. 



*•* If j &lt; n-1, then an open parenthesis is printed. 



This causes the contents to be printed in a format suitable for :initial-contents to <ClLinks styled={true} term={"make-array"}><b>make-array</b></ClLinks>. The lists effectively printed by this procedure are subject to truncation by **\*print-level\*** and <ClLinks styled={true} term={"print-length"}><b>\*print-length\*</b></ClLinks>. 



If the <ClLinks styled={true} term={"array"}><i>array</i></ClLinks> is of a specialized <ClLinks styled={true} term={"type"}><i>type</i></ClLinks>, containing bits or characters, then the innermost lists generated by the algorithm given above can instead be printed using bit-vector or string syntax, provided that these innermost lists would not be subject to truncation by <ClLinks styled={true} term={"print-length"}><b>\*print-length\*</b></ClLinks>. 



If both <ClLinks styled={true} term={"print-array"}><b>\*print-array\*</b></ClLinks> and <ClLinks styled={true} term={"print-readably"}><b>\*print-readably\*</b></ClLinks> are <ClLinks styled={true} term={"false"}><i>false</i></ClLinks>, then the <ClLinks styled={true} term={"array"}><i>array</i></ClLinks> is printed in a format (using #&lt;) that is concise but not readable. 



If <ClLinks styled={true} term={"print-readably"}><b>\*print-readably\*</b></ClLinks> is <ClLinks styled={true} term={"true"}><i>true</i></ClLinks>, the <ClLinks styled={true} term={"array"}><i>array</i></ClLinks> prints in an <ClLinks styled={true} term={"implementation-defined"}><i>implementation-defined</i></ClLinks> manner; see the <ClLinks styled={true} term={"variable"}><i>variable</i></ClLinks> <ClLinks styled={true} term={"print-readably"}><b>\*print-readably\*</b></ClLinks>. In particular, this may be important for arrays having some dimension 0. 



For information on how the *Lisp reader* parses these “other <ClLinks styled={true} term={"array"}><i>arrays</i></ClLinks>,” see Section 2.4.8.12 (Sharpsign A). 



